; Daniel Mitchell
; P9 - Sort
; November 4, 2020
; CSC 245 def helped with this
%macro	print	2
	pusha
 	mov eax, 4
	mov ebx, 1
	mov ecx, %1
	mov edx, %2
	int 80h
	popa
%endmacro

%macro printArray	0 
	
	mov al, [nums+edx]
	call _convert
	print output, 4
	inc edx
	
%endmacro

%macro printArray 2	;%1 is the array reference, %2 is the arraylen
	mov ecx, %2
	mov eax, %1
	call _arrayPrinter
%endmacro

SECTION .data
; define data/variables here.  Think DB, DW, DD, DQ
output:	db	"   ", 10
nums:	db	210, 33, 5, 1, 7
numslen: EQU $-nums
ten:	db	10
hundred:db	100

clr	db	1bh,'[2J'

ogHeader: db	"Original Array", 10
oglen:	EQU $-ogHeader

sortedHeader: db	"Sorted Array", 10
sortedlen: EQU $-sortedHeader

SECTION .bss
; define uninitialized data here

SECTION .text
global _main
_main:
call	_clrscr
; put your code here.
print	ogHeader, oglen


mov ecx, numslen
mov edx, 0
unsortedPrint:
printArray
loop unsortedPrint

call	_sortEm

mov edx, 0
mov ecx, numslen

print	sortedHeader, sortedlen
sortedPrint:
printArray
loop sortedPrint


lastBreak:
; Normal termination code
mov eax, 1
mov ebx, 0
int 80h


_convert:	;al should have byte number

b2:

pusha
mov	ebx, output	
xor	ah, ah		;clears ax so al has the number passed in
div	BYTE [hundred]  ;gets the car value
add	al, '0'
mov	[ebx], al
inc	ebx
shr	ax, 8
div	BYTE [ten]
add	al, '0'
mov	[ebx], al
add	ah, '0'
inc	ebx
mov	[ebx], ah

popa 
ret

_sortEm:
pusha
mov	ebx, 0
mov	edx, 1
mov	ecx, numslen
sortLoop:

comp:
mov	al, [nums+ebx]
mov	dl, [nums+edx]
cmp	al, dl

jc end

;mov	[nums+ebx], dl
;mov	[nums+edx], al
xchg	dl, al

end:
inc 	edx
inc 	ebx
loop sortLoop

popa
ret

_clrscr:
pusha
mov	eax, 4
mov	ebx, 1
mov	ecx, clr
mov	edx, 4
int	80h
popa
ret

